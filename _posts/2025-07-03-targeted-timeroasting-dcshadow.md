# ClockMock: Merging TimeRoasting with DCShadow for "Stealth" Operations

Hey, **welcome to my blog**. This is my **first post**, and I sincerely hope you’ll enjoy it. In this article, based on my research, we’ll explore a potential new `attack surface` that combines **stealth** and **performance**. Please don’t mock the **name**; I just **made it up** to give my article a good title, so feel free to choose the `path` however you’d like. In this **article**, we’ll **cover** a range of **fascinating** `topics`, notably the dissection of the **NTP protocol**, and more specifically the specification of the `Network Time Protocol (NTP) Authentication Extensions`, which provides an authentication mechanism for **NTP version 3** (`RFC 1305`) and for **SNTP version 4** (`RFC 2030`). 

Subsequently, we’ll **delve into** the study of the `classic TimeRoasting attack`, so as not to get lost later when presenting the `Targeted TimeRoasting attack`. Then, we’ll **examine** the workings of the `DCShadow attack`, in order to finally **introduce** the article’s key subject: the **combination** of the two for a true masterstroke.

## NTP Protocol

**Network Time Protocol** (`NTP`) is a network protocol, originally defined in `RFC 1305` (updated by `RFC 5905`), whose **objective** is to **synchronize** the internal clocks of computer systems with each other and with **Coordinated Universal Time** (`UTC`). It relies on exchanges of `UDP` packets (`port 123`) and uses an **intersection algorithm** (a variant of the **Marzullo algorithm**) to select the most reliable **time sources** and compensate for variable **network latency**. It is an **Application‑layer protocol** (`Layer 7` of the OSI model). It relies on `UDP` (`Layer 4` – Transport) to exchange its datagrams (port `123`), but the actual **time synchronization service** resides in the **Application layer**.

**An NTP packet** is a fixed `48 bytes` long and encoded in **big‑endian** order. Let’s walk now through each **field** as if we were gently unpacking a neatly wrapped gift.

First up is the very first **byte**, the packet’s control center. In `bits 7–6`, we have the **Leap Indicator**, a tiny **two‑bit** flag that quietly tells us whether a leap second is on its way (or if something has gone awry). Right next door, in `bits 5–3`, sits the **Version Number**, letting both peers agree on which **edition** of **NTP** they’re speaking, `version 3` and `4` being the ones you’ll meet in the wild. Finally, `bits 2–0` hold the **Mode**, which defines the **role** this packet plays: client, server, broadcaster, or even peer‑to‑peer. Together, these three sub‑fields make sure everyone’s speaking the same language, knows their part, and can handle special cases like leap seconds.

Moving on, **bytes 1–3** tell us a bit about **"who"** and **"how often."** `Byte 1`, the **Stratum**, indicates our distance from the ultimate time source: `stratum 1` servers are hooked up to atomic clocks or **GPS**, while `stratum 2` and beyond cascade their sync from above. `Byte 2` is the **Poll Interval**, a **power‑of‑two** count that hints how frequently this node is willing to exchange messages, think of it as the node’s handshake cadence. In `Byte 3`, the **Precision** field whispers the system clock’s granularity: a signed **power‑of‑two** exponent that, for instance, might mean a resolution down to microseconds.

**Bytes 4–11** are the packet’s built‑in speedometer and error gauge. The **Root Delay** (`bytes 4–7`) measures the round‑trip delay back to the primary reference clock in a **fixed‑point** format, while the **Root Dispersion** (`bytes 8–11`) estimates the maximum error introduced along that path. By reading these, a client can decide which server to trust most, favoring low delay and low dispersion for the sharpest time.

Next, in **bytes 12–15**, the **Reference ID** tags exactly which upstream source handed you your time: an ASCII code like `GPS` on `stratum 1`, or the IP address of the server you spoke to if you’re `stratum 2` or lower. It’s a breadcrumb trail, helping you detect routing loops or misconfigurations.

Finally, the heavyweight hitters: our four `64‑bit` timestamps. The **Reference Timestamp** (`bytes 16–23`) marks when this clock was last set or corrected. The **Originate Timestamp** (`bytes 24–31`) is simply the client’s own transmit time echoed back by the server. The **Receive Timestamp** (`bytes 32–39`) logs exactly when the server got that request, and the **Transmit Timestamp** (`bytes 40–47`) notes when the server sent its response. By comparing these four moments, client send, server receive, server send, client receive, a clever algorithm can tease out both the network delay and the clock offset, letting you nudge your own timepiece into perfect sync.

In just `48 bytes`, **NTP** carries everything it needs: warnings about leap seconds, versioning, role definitions, timing cadence, error estimates, source identifiers, and the timestamps themselves. It’s a marvel of protocol design, squeezing precision and reliability into the smallest possible package.
